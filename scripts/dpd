#!/bin/bash
SCRIPT=$0
DIRNAME=`dirname $SCRIPT`
node - <<'JS' $DIRNAME "$@"
let [ SCRIPT, DASH, DIRNAME, ...args] = process.argv;
const msg = `${SCRIPT}:`;

function help() {
  console.log(`
NAME
        dpd - search Digital Pali Dictionary

SYNOPSIS
        dpd [OPTIONS] PATTERN

DESCRIPTION
        Searches Digital Pali Dictionary using following methods:
        * entries by Pali word
        * entries by matching unaccented Pali word(s)
        * entries by matching definitions

    -?, --help
        Print this help.

    -md
        Use "definition" search method to show matching definitions

    -me
        Use "entry" search method to show definitions for given 
        Pāli word.

    -mu
        Use "unaccented" search method to show definitions for all Pāli 
        words matching unaccented letters with or without diacriticals

EXAMPLES
        dpd dhamma
        dpd -mu dhamma
        dpd -md 'superior virtue'
  `);
  process.exit(0);
}
async function main() {
  const msg = 'dpd.main()';
  const path = (await import('path'));
  const util = require('util');
  const exec = util.promisify(require('child_process').exec);
  const { DBG } = (await import(
    `${DIRNAME}/../src/defines.mjs`));
  const { default:Dictionary } = (await import(
    `${DIRNAME}/../src/dictionary.mjs`));

  let dbg = DBG.DPD;
  let dict = await Dictionary.create();
  let method; // default
  let textArgs = [];
  for (let i=0; i<args.length; i++) {
    let arg = args[i];
    let argNext = args[i+1];
    if (arg.startsWith('-')) {
      switch (arg) {
        case '-me':
          method = 'entry';
          break;
        case '-mu':
          method = 'unaccented';
          break;
        case '-md':
          method = 'definition';
          break;
        case '-?':
        case '--help':
          help();
          break;
      }
    } else {
      textArgs.push(arg);
    }
  }
  if (textArgs.length == 0) {
    help();
  }

  if (textArgs.length > 1) {
    if (!method || method==='definition') {
      method = 'definition'
      textArgs = [ textArgs.join(' ') ];
    }
  }
  for (let i=0; i<textArgs.length; i++) {
    let word = textArgs[i];
    let info = dict.find(word, {method});
    if (info == null) {
      console.log(`${word} (not found)`);
      let words = dict.wordsWithPrefix(word);
      words.forEach(word=>{
        console.log(`  ${word}?`);
      });
      return;
    }
    dbg && console.log(msg, '[1]info', info);
    let { method:methodActual, pattern, data } = info;
    let license = ' CC0 https://digitalpalidictionary.github.io/';
    let title = ` find:"${word}" method:${methodActual}`
    console.log("".padEnd(title.length+1, "-"));
    console.log(title);
    console.log("".padEnd(title.length+1, "-"));
    let T_TYPE = 'TYPE';
    let T_CONSTR = 'CONSTRUCT';
    let T_KEY = 'KEY';
    let T_PATTERN = 'PAT';
    let T_POS = 'POS';
    let T_MEANING ='MEANING';
    let T_WORD = 'WORD';
    let typePad = T_TYPE.length;
    let constrPad = T_CONSTR.length;
    let keyPad = T_KEY.length;
    let patternPad = T_PATTERN.length;
    let posPad = T_POS.length;
    let wordPad = T_WORD.length;
    let rows = data.map(row=>{
      let { 
        key='', word='', type='', meaning='', literal='', 
        construction='', pos='', pattern='', 
      } = row;
      wordPad = Math.max(wordPad, word.length);
      typePad = Math.max(typePad, type.length);
      constrPad = Math.max(constrPad, construction.length);
      keyPad = Math.max(keyPad, key.length);
      patternPad = Math.max(patternPad, pattern.length);
      posPad = Math.max(posPad, pos.length);

      return [
        key, word, type, meaning, literal, 
        construction, pattern, pos,
      ];
    });
    console.log(
      '#'.padStart(2),
      T_KEY.padEnd(keyPad),
      T_WORD.padEnd(wordPad),
      //T_TYPE.padEnd(typePad),
      T_PATTERN.padEnd(patternPad),
      T_POS.padEnd(posPad),
      T_MEANING,
      //T_CONSTR.padEnd(constrPad),
    );
    rows.forEach((row,i)=>{
      let [ 
        key, word, type, meaning, literal, 
        construction, pattern, pos
      ] = row;
      console.log(
        `${i+1}`.padStart(2),
        key.padEnd(keyPad),
        word.padEnd(wordPad),
        //type.padEnd(typePad),
        pattern.padEnd(patternPad),
        pos.padEnd(posPad),
        //construction.padEnd(constrPad),
        literal ? `${meaning}; lit. ${literal}` : meaning,
      );
    });
  }
} //main
main();
JS
