#!/usr/bin/bash
DBNAME=dpd.db
DBSRC=local/$DBNAME
SCRIPT=`basename $0`
DIRNAME=`dirname $0`

set -e # DIE ON ERROR

if [[ -e $DBSRC ]]; then
  echo $SCRIPT "$DBSRC found, building..."
else
  echo $SCRIPT "$DBSRC not found, installing..."
  $DIRNAME/dpd-install
fi

node - <<'JS' $DIRNAME $SCRIPT "$@"
const util = require('util');
const fs = require('fs');
const fsp = fs.promises;
const path = require('path');
const exec = util.promisify(require('child_process').exec);
const MIN_PARMS = 0;
const ROW_LIMIT = 0;
const VERBOSE_ROWS = 3;
let [ NODE, DASH, DIRNAME, SCRIPT, ...args] = process.argv;
const APPDIR = path.join(DIRNAME, '..');
const LOCAL = path.join(APPDIR, 'local');
/////////// TODO BEGIN
const DATADIR = path.join(APPDIR, 'data'); 
/////////// TODO END
const msg = `${SCRIPT}:`;

async function TBD() {
  const textMap = {};

  let SC_DATA_URL = 
    'https://raw.githubusercontent.com/suttacentral/sc-data/main/dictionaries/simple/en/pli2en_dpd.json';
  //let APIURL = 'https://suttacentral.net/api';
  //let url = `${APIURL}/dictionaries/lookup?from=pli&to=en`;
  //let res = await fetch(url);
  let res = await fetch(SC_DATA_URL);
  let resText = await res.text();
  let data = JSON.parse(resText.replace(/ṃ/g, 'ṁ')); // SC anusvāra
  let dataMap = {
    __metadata: {
      license: "https://digitalpalidictionary.github.io/titlepage.html",
      version: "1.0.0",
    }
  }

  let cmprs = new Compress();

  for (let i = 0; i < data.length; i++) {
    let di = data[i];
    let key = di.entry;
    let { definition } = di;

    if (definition) {
      for (let j=0; j<definition.length; j++) {
        let line = definition[j];
        textMap[line] = null;
      }
    }
  }
  let texts = Object.keys(textMap).sort();
  for (let i=0; i<texts.length; i++) {
    let line = texts[i];
    textMap[line] = i;
  }

  for (let i = 0; i < data.length; i++) {
    let di = data[i];
    let key = di.entry;
    let { definition } = di;

    if (definition) {
      definition = definition.map(d=>textMap[d]);
      let info = JSON.stringify({ d:definition });
      if (0) {
        let infoCompress = await cmprs.lzwCompress(info);
        dataMap[key] = infoCompress;
      } else {
        dataMap[key] = info;
      }
    }
  }
  let textPath = `${DIRNAME}/../data/en/dpd-text.mjs`;
  texts = texts.map(line=>{
    let [ type, meaning, litcon ] = line.split(/ *<.?b>/);
    let [ lit, con ] = litcon.split(' [');
    type = type.replace(/\.$/, '');
    lit = (lit||'') && lit.replace(/;? *lit\. */, '');
    con = (con||'') && con.replace(/] */, '').replace(/ \+ /g, '\u02d6');
    return [type, meaning, lit, con].join('|');
  });
  let textJson = JSON.stringify(texts, null,1);
  let textOut = `export const DPD_TEXTS=${textJson}`;
  fs.writeFileSync(textPath, textOut);

  let outPath = `./${DIRNAME}/../local/data/en/dpd.mjs`;
  let out = JSON.stringify(dataMap,null,1);
  out = `export const DPD=${out}`;
  let keys = Object.keys(dataMap);
  fs.writeFileSync(outPath, out);

  console.error(msg, 'DPD dictionary updated', {
    bytes: out.length*2,
    keys: keys.length, 
    outPath,
  });
} // TBD


async function main() {
  const msg = `${SCRIPT}.main:`;
  const Pali = (await import(`${DIRNAME}/../src/pali.mjs`)).default;
  const { default:SqlDpd } = (await import(`${DIRNAME}/js/sql-dpd.mjs`));
  const { Compress } = 
    (await import(`${DIRNAME}/../src/compress.mjs`)).default;

  function help() {
    console.error(`
  NAME
    ${SCRIPT} - build JS DPD files from DPD SQL database

  SYNOPSIS
    ${SCRIPT} [OPTIONS]

  DESCRIPTION
    create new bash script with nodejs wrapper

  OPTIONS
    -?, --help
      print this help text

    -op, --out-patterns [PAT]
      list headword patterns to stdout. Filter by PAT if given.
      (default: off)

    -rl, --row-limit ROWS
      Limit SQL output to given number of rows. If ROWS
      is zero, all rows are processed. (Default: ${ROW_LIMIT})

    -v, --verbose
      print more information to stderr

    -vr, --verbose-rows
      number of rows of verbose information for tabular data.
      (Default: ${VERBOSE_ROWS})

  EXAMPLES
    ${SCRIPT} -rl 0
      Rebuild all.
  `);
    process.exit(0);
  }

  function parseArgs() {
    const msg = `${SCRIPT}.parseArgs:`;
    let result = { // default values
      dbg: 0,
      outPatterns: false,
      parms: [],
      rowLimit: ROW_LIMIT,
      verboseRows: VERBOSE_ROWS,
    }

    for (let i=0; i<args.length; i++) {
      let arg = args[i];
      let argNext = args[i+1] || '';
      switch (arg) {
        case '-?':
        case '--help':
          help();
          break;
        case '-rl':
        case '-row-limit':
          result.rowLimit = Number(argNext);
          i++;
          break;
        case '-op':
        case '--out-patterns':
          if (argNext && !argNext.startsWith('-')) {
            result.outPatterns = argNext;
            i++;
          } else {
            result.outPatterns = '.*';
          }
          break;
        case "--verbose-rows":
        case "-vr":
          result.verboseRows = Number(argNext);
          i++;
          result.dbg = result.dbg || 1; // ensure non-zero
          break;
        case "--verbose":
        case "-v":
          result.dbg = 1;
          break;
        case "--very-verbose":
        case "-vv":
          result.dbg = 2;
          break;
        default:
          if (arg.at(0) === "-") {
            console.error(`${msg} [ERROR] ignoring ${arg}`);
            help();
          } else {
            result.parms.push(arg);
          }
          break;
      } // switch arg
    } // for args
    console.error(msg, '[1]args', args);
    result.dbg && console.error(msg, '[1]result', JSON.stringify(result));
    if (result.parms.length < MIN_PARMS) {
      help();
    }

    result.dbg>1 && console.error(msg, Object.assign({
      NODE,DASH, DIRNAME, SCRIPT, parms:result.parms, 
    }, result));

    return result;
  }
  let {
    dbg,
    outPatterns,
    rowLimit,
    parms,
    verboseRows,
  } = parseArgs();

  // Generate Pali word count from ebt-data/root/pli
  async function buildPaliMap() {
    const msg = `${SCRIPT}.buildPaliMap:`;
    let cmd_ms = path.join('.', 'pli-words');
    console.log(msg, '[2]exec', cmd_ms);
    let { stdout, stderr } = await exec(cmd_ms, {cwd:APPDIR});
    dbg>1 && console.error(msg, '[2.1]stdout', stdout);
    stderr && console.error(msg, '[2.2]stderr', stderr);
    let fnMS = path.join(LOCAL, 'words/ms.json');
    let json = JSON.parse( await fsp.readFile(fnMS) );
    console.error(msg, '[3]readFile', fnMS, Object.keys(json).length);
    return json;
  }
  let paliMap = await buildPaliMap();

  let sqlDpd = await SqlDpd.create({
    dbg: dbg > 1 ? 1 : 0,
    rowLimit,
    dataDir: DATADIR,
    paliMap,
    verboseRows,
  });

  const PATTERNS = await sqlDpd.loadPatterns();
  if (outPatterns) {
    PATTERNS.sort((a,b)=>b.count - a.count);
    let re = new RegExp(outPatterns);
    let pats = PATTERNS.filter(p=>re.test(p.pattern));
    dbg && console.error(msg, 'outPatterns', outPatterns);
    console.log("[");
    pats.forEach((p,i)=>{
      if (i<pats.length-1) {
        console.log(`  ${JSON.stringify(p)},`)
      } else {
        console.log(`  ${JSON.stringify(p)}`)
      }
    });
    console.log("]");
    return;
  }

  await sqlDpd.build();

  console.error(msg, '[5]done');
}
main();

JS

