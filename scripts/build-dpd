#!/usr/bin/bash
DBNAME=dpd.db
SCRIPT=`basename $0`
DIRNAME=`dirname $0`

node - <<'JS' $DIRNAME $SCRIPT "$@"
const util = require('util');
const fs = require('fs');
const fsp = fs.promises;
const path = require('path');
const exec = util.promisify(require('child_process').exec);
const MIN_PARMS = 0;
const ROW_LIMIT = 130;
let [ NODE, DASH, DIRNAME, SCRIPT, ...args] = process.argv;
const LOCAL = path.join(DIRNAME, '../local');
const msg = `${SCRIPT}:`;

async function TBD() {
  const textMap = {};

  let SC_DATA_URL = 
    'https://raw.githubusercontent.com/suttacentral/sc-data/main/dictionaries/simple/en/pli2en_dpd.json';
  //let APIURL = 'https://suttacentral.net/api';
  //let url = `${APIURL}/dictionaries/lookup?from=pli&to=en`;
  //let res = await fetch(url);
  let res = await fetch(SC_DATA_URL);
  let resText = await res.text();
  let data = JSON.parse(resText.replace(/ṃ/g, 'ṁ')); // SC anusvāra
  let dataMap = {
    __metadata: {
      license: "https://digitalpalidictionary.github.io/titlepage.html",
      version: "1.0.0",
    }
  }

  let cmprs = new Compress();

  for (let i = 0; i < data.length; i++) {
    let di = data[i];
    let key = di.entry;
    let { definition } = di;

    if (definition) {
      for (let j=0; j<definition.length; j++) {
        let line = definition[j];
        textMap[line] = null;
      }
    }
  }
  let texts = Object.keys(textMap).sort();
  for (let i=0; i<texts.length; i++) {
    let line = texts[i];
    textMap[line] = i;
  }

  for (let i = 0; i < data.length; i++) {
    let di = data[i];
    let key = di.entry;
    let { definition } = di;

    if (definition) {
      definition = definition.map(d=>textMap[d]);
      let info = JSON.stringify({ d:definition });
      if (0) {
        let infoCompress = await cmprs.lzwCompress(info);
        dataMap[key] = infoCompress;
      } else {
        dataMap[key] = info;
      }
    }
  }
  let textPath = `${DIRNAME}/../data/en/dpd-text.mjs`;
  texts = texts.map(line=>{
    let [ type, meaning, litcon ] = line.split(/ *<.?b>/);
    let [ lit, con ] = litcon.split(' [');
    type = type.replace(/\.$/, '');
    lit = (lit||'') && lit.replace(/;? *lit\. */, '');
    con = (con||'') && con.replace(/] */, '').replace(/ \+ /g, '\u02d6');
    return [type, meaning, lit, con].join('|');
  });
  let textJson = JSON.stringify(texts, null,1);
  let textOut = `export const DPD_TEXTS=${textJson}`;
  fs.writeFileSync(textPath, textOut);

  let outPath = `./${DIRNAME}/../data/en/dpd.mjs`;
  let out = JSON.stringify(dataMap,null,1);
  out = `export const DPD=${out}`;
  let keys = Object.keys(dataMap);
  fs.writeFileSync(outPath, out);

  console.error(msg, 'DPD dictionary updated', {
    bytes: out.length*2,
    keys: keys.length, 
    outPath,
  });
} // TBD


async function main() {
  const msg = `${SCRIPT}.main:`;
  const Pali = (await import(`${DIRNAME}/../src/pali.mjs`)).default;
  const { default:SqlDpd } = (await import(`${DIRNAME}/js/sql-dpd.mjs`));
  const { Compress } = 
    (await import(`${DIRNAME}/../src/compress.mjs`)).default;

  function help() {
    console.error(`
  NAME
    ${SCRIPT} - build JS DPD files from DPD SQL database

  SYNOPSIS
    ${SCRIPT} [OPTIONS]

  DESCRIPTION
    create new bash script with nodejs wrapper

  OPTIONS
    -?, --help
      print this help text

    -op, --out-patterns [PAT]
      list headword patterns to stdout. Filter by PAT if given.
      (default: off)

    -rl, --row-limit ROWS
      Limit SQL output to given number of rows. If ROWS
      is zero, all rows are processed. (Default: ${ROW_LIMIT})

    -v, --verbose
      print more information to stderr

  EXAMPLES
    ${SCRIPT} -rl 0
      Rebuild all.
  `);
    process.exit(0);
  }

  function parseArgs() {
    const msg = `${SCRIPT}.parseArgs:`;
    let result = { // default values
      dbg: 0,
      outPatterns: false,
      parms: [],
      rowLimit: ROW_LIMIT,
      verboseRows: 3,
    }

    for (let i=0; i<args.length; i++) {
      let arg = args[i];
      let argNext = args[i+1] || '';
      switch (arg) {
        case '-?':
        case '--help':
          help();
          break;
        case '-rl':
        case '-row-limit':
          result.rowLimit = Number(argNext);
          i++;
          break;
        case '-op':
        case '--out-patterns':
          if (argNext && !argNext.startsWith('-')) {
            result.outPatterns = argNext;
            i++;
          } else {
            result.outPatterns = '.*';
          }
          break;
        case "--verbose-rows":
        case "-vr":
          result.verboseRows = Number(argNext);
          i++;
          result.dbg = result.dbg || 1;
          break;
        case "--verbose":
        case "-v":
          result.dbg = 1;
          break;
        case "--very-verbose":
        case "-vv":
          result.dbg = 2;
          break;
        default:
          if (arg.at(0) === "-") {
            console.error(`${msg} [ERROR] ignoring ${arg}`);
            help();
          } else {
            result.parms.push(arg);
          }
          break;
      } // switch arg
    } // for args
    console.error(msg, '[1]args', args);
    result.dbg && console.error(msg, '[1]result', JSON.stringify(result));
    if (result.parms.length < MIN_PARMS) {
      help();
    }

    result.dbg>1 && console.error(msg, Object.assign({
      NODE,DASH, DIRNAME, SCRIPT, parms:result.parms, 
    }, result));

    return result;
  }
  let {
    dbg,
    outPatterns,
    rowLimit,
    parms,
    verboseRows,
  } = parseArgs();

  let sqlDpd = new SqlDpd({
    dbg: dbg > 1 ? 1 : 0,
    rowLimit
  });

  const PATTERNS = await sqlDpd.loadPatterns();
  if (outPatterns) {
    PATTERNS.sort((a,b)=>b.count - a.count);
    let re = new RegExp(outPatterns);
    let pats = PATTERNS.filter(p=>re.test(p.pattern));
    dbg && console.error(msg, 'outPatterns', outPatterns);
    console.log("[");
    pats.forEach((p,i)=>{
      if (i<pats.length-1) {
        console.log(`  ${JSON.stringify(p)},`)
      } else {
        console.log(`  ${JSON.stringify(p)}`)
      }
    });
    console.log("]");
    return;
  }

  let headwords;
  try {
    let {stdout,stderr} = await sqlDpd.loadHeadwords();
    headwords = JSON.parse(stdout);
    console.error(msg, '[1]headwords', headwords.length);
    if (dbg) {
      for (let i=0; i<verboseRows; i++) {
        let hwi = JSON.stringify(headwords[i], (k,v)=>v||undefined);
        console.error(' ', hwi);
      }
      console.error('  ...');
    }
  } catch(e) {
    console.error(msg, e);
    throw e;
  }

  // Generate Pali word count from ebt-data/root/pli
  let cmd_ms = path.join(DIRNAME, 'pli-words');
  console.log(msg, '[2]exec', cmd_ms);
  let { stdout, stderr } = await exec(cmd_ms);
  dbg>1 && console.error(msg, '[2.1]stdout', stdout);
  stderr && console.error(msg, '[2.2]stderr', stderr);
  let fnMS = path.join(LOCAL, 'words/ms.json');
  let paliMap = JSON.parse( await fsp.readFile(fnMS) );
  console.error(msg, '[3]readFile', fnMS, Object.keys(paliMap).length);
  let headwordUsage = {};
  let {
    wordMap, wAccept, wReject, wUndefined, wPali,
  } = await sqlDpd.loadLookup({paliMap, headwordUsage});
  let dbgWordMap = Object.keys(wordMap).slice(0,verboseRows)
    .reduce((a,k)=>{
      let v = wordMap[k];
      v && v.length && (a[k] = v);
      return a;
    }, {});
  console.error(msg, '[4]lookup', {
    wordMap: dbgWordMap,
    wAccept,
    wReject,
    wPali,
    wUndefined,
  });
  let hwKeys = Object.keys(headwordUsage).sort((a,b)=>{
    return (headwordUsage[b] - headwordUsage[a]) || (a-b);
  });
  if (dbg) {
    let keys = hwKeys.slice(0, verboseRows);
    let hws =  keys.reduce((a,k,i)=>{
      a += `${k}:${headwordUsage[k]} `;
      return a;
    }, '');
    console.error(msg, '[4.1]headwordUsage', hws);
  }

  console.error(msg, '[5]done');
}
main();

JS

